created: 20220705025136524
creator: TidGiUser
modified: 20220705114100343
modifier: TidGiUser
tags: 分布式ID高性能改造 fx undo
title: 01.java spi机制
type: text/vnd.tiddlywiki

! 自定义全局ID生成策略

sharding jdbc的snowflakes算法解决时钟回拨问题, 不太优雅, 所以需要定制, 利用spi机制

! spi介绍

spi，简单来说，就是 service provider interface，说白了是什么意思呢，比如你有个接口，现在这个接口有 3 个实现类，那么在系统运行的时候对这个接口到底选择哪个实现类呢？这就需要 spi 了，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。

<<<
jdk提供的spi支持：

如果要通过jar包的方式给某个接口提供实现，你就在自己jar包的META-INF/services目录下放一个跟接口同名的文件，里面指定接口的实现类是这个jar包里的某个类。
别人用一个接口，同时用了这个jar包，就会在运行的时候通过jar包中的那个文件找到接口该用哪个实现类
<<<

感觉上是和[[策略模式]]很像的 ,

* 都是符合''开闭原则'', 一般是框架的提供方定义接口, 调用方去实现具体的实现类

* 但是策略模式一般是类层次上的隔离,''而SPI机制则是项目框架级别的隔离'', 一般是引入新的jar包

因此spi 机制一般用在哪儿？''插件扩展的场景''，比如说你开发了一个给别人使用的开源框架，如果你想让别人自己写个插件，插到你的开源框架里面，从而扩展某个功能，这个时候 spi 思想就用上了

---
尼恩:

SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件,''让服务的调用方(例如:调用方定义了jdbc接口)和提供方(例如:提供方实现oracle,mysql的jdbc实现)解耦''

系统设计的各个抽象，往往有很多不同的实现方案，在面向的对象的设计里，一般推荐模块之间''基于接口编程''，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。

''为了实现在模块装配的时候能不在程序里动态指明''，这就需要一种服务发现机制。Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似[[IOC]]的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。

> ioc是框架提前并不知道需要实例化那些用户自定义的类,spi也是吗???''

> 感觉用spring也能实现这种服务调用方与提供方的解耦,大家都依托于容器,调用方写调用逻辑,定义接口, 提供方去实现接口,并且通过配置指明使用哪一个实现类, 容器自己会去完成扫描,将实现类装入容器''

[img[截屏2022-07-05 11.23.41.png]]

java spi的使用约定:

要使用Java SPI，需要遵循如下约定：

> 感觉和ioc差不多

1、当服务提供者提供了接口的一种具体实现后，在jar包的META-INF/services目录下创建一个以“接口全限定名”为命名的文件，内容为实现类的全限定名；

2、接口实现类所在的jar包放在主程序的classpath中；

3、主程序通过java.util.ServiceLoder动态装载实现模块，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM；

4、SPI的实现类必须携带一个不带参数的构造方法；

