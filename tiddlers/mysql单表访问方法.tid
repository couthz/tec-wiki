created: 20220615235307965
creator: TidGiUser
difficulty: 5
due: 20220623111746157
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220621111746157
modifier: TidGiUser
reps: 1
retrievability: 1
review: 20220621111746157
stability: 2
tags: mysql查询优化 fx ?
title: mysql单表访问方法
type: text/vnd.tiddlywiki

! 查询优化器的作用
* 用哪些索引？

* 表之间的连接顺序

* 最后，按计划调用存储引擎中的方法执行真正的查询

! 查询执行的方式分类
* 全表扫描
* 使用索引查询
** 针对主键或唯一二级索引的等值查询
** 针对普通二级索引的等值查询
** 针对索引列的范围查询
** 直接扫描整个索引

> 有啥区别呢？？？

! 访问方法（访问类型）
1. const （常数级别）

使用主键或唯一二级索引的与''常数''等值查询

注：

* 唯一二级索引不会限制null的数量，所以和is null不属于const
* 不用担心回表，反正也是常数次

2. ref

使用普通二级索引列进行与常数的等值查询，效率取决于''回表次数''，也就是''包含该常数的二级索引列有多少''

注：

* 效率是不确定的，一次回表就是一次随机IO，假如查到了二级索引的所有列，那还不如直接去全表扫描
> 这里可以用后面的[[查询优化|mysql基于成本的优化：单表]]来解释

* ''最左匹配原则：''假如用到了联合索引index(key1,key2,key3),只需要最左边连续的列与常数等值查询，就是ref，无非就是用到的列越少''可能''回表的次数更多

*'' 注意！！！''以上规则引导你设计两到三个联合索引：''尽量让你的所有sql中的where，order by， group by后面跟的字段顺序，都是某个联合索引最左侧开始的部分字段''

3. ref_or_null

使用二级索引（唯一，普通）与常数 or null进行等值查询

和ref类似

4. range

使用索引（聚簇，二级）进行范围匹配，也适用''最左匹配原则''

注：where key in (123,23) or (key >= 9 and key <=233) 这种同时有''单点区间''和''连续区间''的条件，肯定是range，单纯的单点区间可以是const或者ref

效率依然取决于回表次数

5. index

通过遍历二级索引，不回表就能找到记录的查询方式称为index

解释：select key1, key2, key3 from table where key2 = 'abc'

* 由于查询条件不符合最左原则，因此不能用二级索引，用不了ref或者range
* 查询的列包含在联合索引中，可以不回表就能查到所有列

6. all

遍历聚簇索引

---
总结：

const适用于聚簇和唯一二级索引的常数等值查询（''注意：这一条并不适合最左匹配原则，一定要全部列匹配,不然就会退化成range''）

ref，ref_or_null, range 其实差不多，共同点是二级索引查询的记录可能都不唯一，效率上都取决于回表次数，而且都使用最左原则（''ref_or_null，null情况和非null的情况分开查''）

ref，ref_or_null, range效率有可能都比all要差

! 注意事项
1. 如果查询条件中有多个二级索引，一般只会用一个二级索引，其他条件在回表的时候再过滤（例外情况：索引合并）

注：此时会利用true替换掉没用到的条件，''因此如果用or连接，会导致索引都用不上''，比如
select * from table where a > 1 or b < 1,这种化简之后就是select * from
table，直接全表扫描就行

2. 明确range的范围区间

确定的方法就是上面提到的：

* 把用不到索引的搜索条件替换为true

* 把用到索引的搜索条件取交集或者并集，一定不可能的条件替换为false（如a>2 and a < 1）

* 分不同索引的情况讨论，找出成本最低的

''3. 索引合并''

在1中提到一般是用一个二级索引，其余条件回表的时候过滤，不过也有例外情况：

（1）Intersection索引合并：

例子：select * from table where key1 = ‘a' and key2 = ’b‘

如果采用一个二级索引+回表的方式，就会''访问更少的二级索引，但是会有更多的回表''

如果Intersection索引合并，就会''访问更多的二级索引（顺序IO），并且需要取记录id的交集，但是会有更少的回表（随机IO）''

''显然，如果减少的回表损耗 > 访问更多二级索引取交集的损耗，用Intersection索引合并更合适''

''注：Intersection索引合并的触发前提''：（和取交集的损耗有关）

1. 二级索引必须是等值匹配，联合索引必须全部列匹配，''保证id有序''

2. 主键列可以是范围匹配

''id有序的情况，取交集就是个O(n)的操作''

> 按照有序的主键值去回表取记录有个专有名词儿，叫：Rowid Ordered Retrieval，简称ROR，但是注意，虽然id有序，但并不一样在聚簇索引中是连续的

''注意：如果经常用到intersection索引合并，那不妨直接建立联合索引，直接就省去了访问更多二级索引取交集的操作''

（2）Union合并

例子：select * from table where key1 = ‘a’ or key3 = ‘b’

这种如果按照1的说法，乍一看得用全表扫描了，但是这里可以用union（''所以权衡时union也是和全表扫描对比的''）

触发条件：
1，2同intersection合并，也是因为''id有序的情况，取并集就是个O(n)的操作''

3. 搜索条件的某些部分使用Intersection索引合并的方式得到的主键集合和其他方式得到的主键集合取交集。

如（。。and。。。） or （。。and 。。。）

''这种相当于用Intersection索引合并先得到有序的id集合''

（3）sort-union合并

例子：select * from table where key1 < ‘a’ or key3 > ‘b’

放开了union的第一个条件，允许范围匹配，导致二级索引查询结果中的id无序，所以增加了排序的开销

''为什么没有sort-insection？？''

因为使用union或者sort-union的初衷是''不想用全表扫描''，适用的场景本身就是单个二级索引查出的记录比较少，合并之后也比较少，以至于回表次数也比较少，效率好过全表扫描

但是使用intersection的初衷是''单个二级索引回表太多''，这个时候如果又排序，开销就太大了

! 一个案例举出单表查询可能的方式
select * from t where key1 = 3 and key2 < 'd'

1. 在key1上建立索引，可能会是const或者ref，如果是const效率就高了，ref就得看回表次数
''（多表查询中，如果在被驱动表上对聚簇或者二级索引使用常数等值查询，叫做eq_ref）''

2. 在key2上建立索引，可能是range，得看回表次数

3. key1，key2上建立联合索引，还是range，回表次数肯定要比1，2要少，''但是联合索引的列数越多，可能适用的sql越少''

4. 有可能索引合并，假如两个条件查到的记录多，但是交集之后结果少

5. 前四种都是二级索引+回表，有可能都不用，直接全表扫描

6. 尽量不用select *，指定明确的查询列，有机会用到index方式
