created: 20220619135644662
creator: TidGiUser
modified: 20220620055757536
modifier: TidGiUser
tags: 线程安全:原子性
title: CLH锁:AQS的前置知识
type: text/vnd.tiddlywiki

! CAS总线风暴
[[CAS]]的介绍中可以看到有关总线风暴的知识:

CAS操作对应的底层指令:cmpxchg(Compare and Exchange)

程序会根据当前处理器的类型是否为多核处理器，来决定是否为cmpxchg指令添加lock 前缀。如果程序是在多处理器上运行，就为 cmpxchg 指令加上 lock 前缀(lock cmpxchg)。反之， 如果程序是在单处理器上运行，就省略 lock 前缀，因为单处理器不需要 lock 前缀提供的内存屏障 效果。

介绍 volatile 关键字原理时讲到，Lock 前缀指令有以下三个作用:

(1)将当前处理器缓存行的数据立即写回系统内存。

(2)Lock 前缀指令会引起在其他 CPU 里缓存了该内存地址的数据无效。 

(3)Lock 前缀指令禁止指令重排。

为了保障“Cache 一致性”， 不同的 Core 需要通过总线的来回通信，所产生的流量一般称为“Cache 一致性流量”。因为总线 被设计为固定的“通信能力”，如果 Cache 一致性流量过大，总线将成为瓶颈，这就是所谓的“总 线风暴”。

那么，JUC 基于 CAS 实现的轻量级锁，如何避免总线风暴呢?答案是:使用队列对抢锁线性进行排队，最大程度上减少了 CAS 操作数量。

! CLH队列
[img[截屏2022-06-20 13.29.01.png]]

简单的 CLH 锁可以基于单向链表实现，申请加锁的线程首先会通过 CAS 操作在单向链表的尾部增加一个节点，之后，''该线程只需要在其前驱节点上进行普通自旋，等待前驱节点释放锁即可(因为只有自己抢前驱节点)''。由于CLH锁只有在节点入队时进行一下 CAS的操作，在节点在加入队列之后，抢锁线程不需要进行CAS自旋，只需普通自旋即可。所以，在争用激烈的场景下，CLH 锁能大大减少的CAS操作的数量，以避免CPU的总线风暴。

! 番外:分布式锁的内部队列

[img[截屏2022-06-20 13.30.09.png]]

