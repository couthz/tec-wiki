created: 20220706083827982
creator: TidGiUser
modified: 20220707002212713
modifier: TidGiUser
tags: mysql事务(主要基于inoodb的原理) fx mysql主从复制与读写分离
title: 02.redo log
type: text/vnd.tiddlywiki

! redo log保障持久性,数据可靠性的技术:WAL

MySQL里常说的WAL技术，全称是Write Ahead Log，''即当事务提交时，先写redo log，再修改页。''

<<<
redo log&Write-Ahead 的本质: 

MySQL真正使用WAL的原因是：磁盘的写操作是随机IO，比较耗性能，所以如果把每一次的更新操作都先写入log中，那么就成了顺序写操作，实际更新操作由后台线程再根据log异步写入。这样对于client端，延迟就降低了。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的IO次数也大大降低。所以WAL的核心在于将随机写转变为了顺序写，降低了客户端的延迟，提升了吞吐量。
<<<

[img[截屏2022-07-06 23.11.03.png]]

! 保障数据可靠性的另一个技术:两阶段提交

!! 前置知识：XA事务，

我们知道MySQL分为server层和存储引擎层，而事务具体是在''存储引擎层''实现的，对于支持事务的存储引擎来说，它们提供了相应的开启事务、提交事务的接口。server层只需要调用这些接口，来让存储引擎执行事务。

在书写包含在一个事务中的语句时，不同语句可能会涉及不同存储引擎的表，这时如果我们想保持整个事务要么全部执行，要么全部不执行的话，本质上就需要保证各个存储引擎的事务全部提交，或者全部回滚。不能存在某些存储引擎事务提交了，某些存储引擎事务回滚了的情况。

稍微总结一下就是：我们有一个大的事务，我们可以称其为全局事务，这个全局事务由若干的小的事务组成。要实现这个大的事务，就必须让它对应的若干个小的事务全部完成，或者全部回滚。我们也可以把这个大的全局事务称作''分布式事务''。''跨多个系统的操作也可以被称作分布式事务。''

有一个名叫X/Open（这名儿听着就挺霸气）的组织提出了一个名为XA的规范，提出了2个角色：

# 一个全局事务由多个小的事务组成，所以我们得在某个地方找一个总揽全局的家伙，这个家伙用于和各个小事务进行沟通，指导它们是提交还是回滚。这个家伙被称作事务协调器（Transaction Coordinator）或者资源管理器（Resource Manager）。

# 管理一个小事务的家伙被称作事务管理器（Transaction Manager）。

''此时大哥不能让各个小弟逐个提交，因为不能保证后面提交的小弟是否可能发生错误''。此时XA规范中指出，要提交一个全局事务，必须分为2步：

# Prepare阶段：当大哥准备提交一个全局事务时，会依次通知各个小弟说：“现在事务中的语句都已经执行完了，我们准备提交了，你这里有没有什么问题？”。如果小弟觉得自己没有问题，就把在事务执行过程中所产生的redo日志都刷新到硬盘，然后对大哥说：“没有问题”。如果小弟遇到了啥突发情况不能提交（比方说磁盘满了，不能写redo了），就对大哥说：“不行，提交不了了”。

# Commit阶段：如果在Prepare阶段各个小弟给大哥的答复都是:“OK，木有问题”，那大哥就要真正通知各个小弟去提交事务了。如果在Prepare阶段某个小弟给大哥的回复是：“NO，做不了”，那大哥就得通知所有小弟：“遇到突发情况，所有人立即回滚”。小弟收到通知便都回滚了。不过在大哥通知各个小弟是要提交之前，都需在某个地方记录一下这个全局事务已经提交，以及各个小弟都是什么的信息。

XA规范把上述全局事务提交时所经历的两个阶段称作两阶段提交。

外部XA：略

内部XA：

在MySQL内部执行一个事务时，存储引擎会修改相应的数据，server层会记录语句对应的binlog。''这是两个要么都完成，要么都不完成的事情''。否则的话：

# 如果存储引擎修改了相应数据并且提交了事务，而server层却未写入binlog。在有主从复制的场景中，意味着这个事务不会在从库中得已执行，从而造成主从之间的数据不一致。

# 如果server层写入了binlog，但存储引擎却回滚了事务。在有主从复制的场景中，意味着这个事务会在从库中得已执行，从而造成主从之间的数据不一致。

''那我们需要保证：如果存储引擎提交了事务，server层的binlog日志必须也被写入到硬盘上；如果存储引擎回滚了事务，server层的binlog日志必须不能被写入到硬盘上。''

MySQL采用内部XA来实现上述内容

!! 两阶段提交

回顾：[[0.各种log的修改流程]],在执行commit时执行两阶段提交：

1. prepare阶段： redo log刷盘， 并且状态设置为prepare

2. commit阶段：binlog刷盘,并且会将redo log状态设置commit，同时将binlog文件的位置也写入

https://baijiahao.baidu.com/s?id=1719905225647709469&wfr=spider&for=pc

根据两阶段提交，崩溃恢复时的判断规则是这样的：

* 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交（也就不用检查binlog了）

* 如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整，如果 binlog 存在并完整，则提交事务；否则，回滚事务

> ''我觉得这个地方，commit标记主要是说明redo log和binlog此时是一致的， redo log持久化主要是为了单机数据最终持久化（主要还是用在崩溃恢复的情况）（预写），binlog持久化意味着主从复制完成， 要保证二者是同一个大事务。''
