created: 20220531075018152
creator: TidGiUser
difficulty: 6.1000000000000005
due: 20220611003921485
grade: 0
history: [{"due":"20220610080810265","interval":0,"difficulty":5,"stability":2,"retrievability":1,"grade":-1,"lapses":0,"reps":1,"review":"20220608080810265"}]
interval: 2
lapses: 1
modified: 20220624071501711
modifier: TidGiUser
reps: 1
retrievability: 0.9
review: 20220610003921485
stability: 1.4816364413634358
tags: [[00 Synchronized]] $:/tags/Commander/Working fx ?
title: 01.synchronized锁升级
tmap.id: 25b58d28-8613-46ae-a3cc-1f86fc347906
type: text/vnd.tiddlywiki

! markword表示锁类型
[img[markword.png]]
markword的最后2bit表示锁类型：

00:轻量锁

10:重量锁

11:GC标记

由于2bit不够表示5种类型，所以又借了前面一位

001:无锁

101:轻量级锁

! 无锁状态
Java 对象刚创建时，还没有任何线程来竞争，说明该对象处于无锁状态(无线程竞争它),偏向锁标识位是 0、锁状态 01

! 偏向锁
!! 原理

如果一个线程获得了锁，那么锁就进入偏向模式，此时 Mark Word 的 结构也变为偏向锁结构，''当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程， 这样就省去了大量有关锁申请的操作''，从而也就提升程序的性能

在无竞争时，之前获得锁的线程再次获得锁时，会判断偏向锁的线程 ID 是否指向自己

如果是，那么该线程将 不用再次获得锁，直接就可以进入同步块

''如果未指向当前线程，则当前线程会采用 CAS 操作 将 Mark Word 中线程 ID 设置为当前线程 ID''，如果 CAS 操作成功，则获取偏向锁成功，去执行 同步代码块，如果 CAS 操作失败，则表示有竞争，抢锁线程被挂起，''撤销''占锁线程的偏向锁， 然后将偏向锁膨胀为轻量级锁

!! 优缺点

偏向锁优点:偏向锁是针对于一个线程而言,在没有多个线程争抢锁的情况下,不会去申请os级别的锁,避免了申请释放锁的开销

偏向锁的缺点:如果锁对象时常被多条线程竞争，那偏向锁就是多余的，并且其撤销的过程会带来一些性能开销。

!! 关于全局安全点

撤销过程的步骤:

(1)JVM 需要等待一个''全局安全点(global safe point)''，当 JVM 到达全局安全点后，所有 的用户线程都是暂停的，当然，在此时，持有偏向锁的用户线程也被暂停了。

(2)遍历线程的栈帧，检查是否存在存在锁记录。如果存在锁记录的话，需要清空锁记录， 使其变成无锁状态，并修复锁记录指向的 Mark Word，清除其线程 ID。

(3)将当前锁升级(或碰撞)成轻量级锁。少数场景直接升级为重量级锁。

(4)唤醒当前线程。

什么是全局安全点(global safe point)?

总体来说，JVM 的全局安全点，指得是当线程运行到 这类位置时，堆对象状态是确定一致的，JVM 可以安全地进行一些全局性的操作，如 GC，偏向 锁解除等。在到达全局安全点后，JVM 里的所有工作的用户线程都会被挂起，只有垃圾收集的 native 线程会持续不断地跑。也就是说，全局安全点(safe point)会触发 JVM 的 STW(stop the world) 停顿。

JVM 如何进入到进入到 global safe point?

(1)JVM 设置一个 global safe point 标志位，各用户线程都有自己的安全点(safe point)(JIT编译方式会在代码中插入safe point,不能太多或者太少)，当用户线程到达 safe point 后，都会去检 查全局 global safe point 标志位，如果发现标志位为 true，安全地将自己挂起。

(2)JVM 里面所有的用户线程都到底安全点(safe point)之后，此时，所有的用户线程都 已经挂起，JVM 处于 STW 停顿状态，JVM 也达到一个全局安全点 global safe point

''偏向锁的取消操作，需要依赖 JVM 的 global safe point (全局安全点)，从而会带来 STW 停顿。如果偏向锁取消操作发生频繁，会招来频繁的 STW， 从而导致严重的性能问题。
''
''所以，对于高并发应用来说，一般建议关闭偏向锁。具体的方式:可以在启动命令中加上以 下 JVM 参数:''

    -XX:-UseBiasedLocking
		
! 轻量级锁

[img[截屏2022-06-24 12.02.19.png]]

!! 原理

1. JVM 首先将在抢锁线程的栈帧中建立一个锁记录(Lock Record)，用于存储对象目前 Mark Word 的拷贝

2. 抢锁线程进行CAS 自旋。抢 锁线程通过 CAS 自旋操作，尝试将内置锁对象头的 Mark Word 的 ptr_to_lock_record(锁记录指 针)更新为抢锁线程栈帧中 Lock Record 的地址，如果这个更新执行成功了，那么这个线程就拥 有了这个对象锁。然后 JVM 将 Mard Word 中的 lock 标记位改为 00(轻量级锁标志)，即表示该 对象处于轻量级锁状态

3. Mark Word 值被 CAS 更新之后，包含锁对象信息(如 hashcode 等)的旧值会被返回，在Lock Record会将旧值保存起来, 将来锁释放的时候还会恢复

!! 分类

1. 普通自旋锁: 线程自旋10次以上还没抢到锁, 会升级成重量级锁

2. 自适应自旋锁(1.7以后)???:

(1)如果抢锁线程在同一个锁对象上之前成功获得过的锁，那么 JVM 就会认为这次自旋也 很有可能再次成功，因此允许自旋等待持续相对更长的时间。

(2)如果对于某个锁，抢锁线程在很少成功获得过，那么 JVM 将可能减少自旋时间甚至省 略自旋过程，以避免浪费处理器资源

!! 轻量级锁的问题

虽然大部分临界区代码的执行时间都是很短的，''但是，也会存执行得很慢的临界区代码。由于临界区代码执行耗时较长，在其执行期间，其他线程都在原地自 旋等待，会空消耗 CPU。所以，如果竞争这个同步锁的线程很多，就会有多个线程在原地等待继 续空循环消耗 CPU(空自旋)，这会带来很大的性能损耗''。

轻量级锁(Lightweight Locking)本意是为了减少多线程进入操作系统底层的互斥锁(Mutex Lock)的机率，并不是要替代操作系统互斥锁。所以，在争用激烈的场景下，轻量级锁会膨胀为 基于操作系统内核互斥锁(Mutex Lock)实现的重量级锁

! 重量级锁
!! 原理
[img[截屏2022-06-24 15.13.49.png]]

! 总结锁升级过程

总结一下 synchronized 的执行过程，大致如下:

(1)线程抢锁时，JVM 首先检测内置锁对象 Mark Word 中 biased_lock(偏向锁标识)是否 设置成 1，lock(锁标志位)是否为 01，如果都满足，确认内置锁对象为可偏向状态。

(2)在内置锁对象确认为可偏向状态之后，JVM 检查 Mark Word 中线程 ID 是否为抢锁线 程 ID，如果是，则表示抢锁线程处于偏向锁状态，抢锁线程快速获得锁，开始执行临界区代码。

(3)如果Mark Word中线程ID并未指向抢锁线程，则通过CAS操作竞争锁。如果竞争成 功，则将 Mark Word 中线程 ID 设置为抢锁线程、偏向标志位设置为 1、锁标志位设置为 01，然 后执行临界区代码，此时内置锁对象处于偏向锁状态。

(4)如果 CAS 操作竞争失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。

(5)JVM 使用 CAS 将锁对象的 Mark Word 替换为抢锁线程的锁记录指针，如果成功，抢 锁线程获得锁。如果替换失败，表示其他线程竞争锁，JVM 尝试使用 CAS 自旋进行抢锁线程的 锁记录指针替换，如果自旋成功(抢锁成功)，则锁对象依然处于轻量级锁状态。

(6)如果 JVM 的 CAS 替换锁记录指针自旋失败，则轻量级锁膨胀为重量级锁(Monitor)， 后面等待锁的线程也要进入阻塞状态。

总体来说，偏向锁是在没有发生锁争用的情况下使用;一旦有了第二个线程的争用锁，偏向 锁就会升级为轻量级锁;如果锁争用很激烈，轻量级锁的 CAS 自旋到达阈值后，轻量级锁就会升 级为重量级锁.