created: 20220615070812682
creator: TidGiUser
difficulty: 5
due: 20220623111737201
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220621111737201
modifier: TidGiUser
reps: 1
retrievability: 1
review: 20220621111737201
stability: 2
tags: 04.mysql是怎么加锁的？？ fx ?
title: 锁定读语句加锁分析：RU和RC
type: text/vnd.tiddlywiki

以下四种归结到一起分析：

select lock in share mode

select for update

update

delete


示例表：
[img[截屏2022-06-15 15.08.35.png]]

>''值得注意的是，采用加锁方式解决并发事务带来的问题时，其实脏读和不可重复读在任何一个隔离级别下都不会发生（因为读-写操作需要排队进行）''

> 而锁定读时，RR，S可以加gap锁，所以RR，S都可以解决幻读？？


在RU下语句的加锁方式和RC隔离级别下语句的加锁方式基本一致，所以就放到一块儿说了。

! 使用主键进行等值查询的情况

重启之后没了，懒得再写了，自己回忆一下吧

主要是注意更新了二级索引的情况，加锁顺序，还有[[死锁|mysql死锁]]问题

! 使用主键进行范围查询的情况
>先关注一下[[ICP:索引条件下推]]

1. select * from hero where number <= 8 lock in share mode

（1）利用聚簇索引找到符合条件的第一条记录，加s锁

（2）判断该记录是否符合索引条件下推（这里不需要，ICP适用于二级索引）

（3）innodb判断当前记录是否越界，如果不越界就返回给server继续判断，否则就释放掉记录上的锁，同时返回给server查询结束的信息（此时就跳出循环）

（4）如果查询没结束，server继续判断是否越界（重复判断一次），以及其他where条件是否符合，如果都符合就返回给客户端，不符合就释放掉记录上的锁

（5）沿链表继续走，给下一条记录加锁，重复（3）（4）（5）直到查询结束

> ''总结起来无非就是边查询边给记录加锁（会不会也出现[[死锁|mysql死锁]]呢？？）'' 

> 并且有个问题是，''会先给第一个超过边界的记录加锁，然后释放锁，这里会有个问题，假如正好有其他事务想对那个记录上锁，可能就会互斥，然而理论上两个事务的查询并无交集''
> 注意如果是supremum infimum伪记录，不会加锁

2. ...for update

类似，加x锁

3. update set where number >= 8

如果没更新二级索引列，和2类似

如果更新了二级索引列，那么类比一下之前等值查询，就是：''先给聚簇索引加锁，然后判断边界，然后给二级索引加锁''

> 这样的话，刚刚超出边界的那条二级索引记录就不会加锁了

4. delete

和 3一致，但是应该会给所有关联到的二级索引列加锁

''总结：边查询边加锁，如果更新了二级索引，加锁顺序就是先聚簇-再判断边界-二级，注意会有超出边界数据先加锁再解锁的问题''


! 使用二级索引进行等值查询
>  在RU和RC隔离级别下，使用普通的二级索引和唯一二级索引进行加锁的过程是一样的，所以我们也就不分开讨论了

1. SELECT * FROM hero WHERE name = 'c曹操' LOCK IN SHARE MODE;

先对二级索引记录加s锁，再对聚簇索引记录加s锁（和前面的update等值查询可能会有[[死锁|mysql死锁]]）

> 注意这里和前面范围查询不同的是，不会对超出边界的记录先加锁，InnoDB对等值匹配的条件有特殊处理，他们规定在InnoDB存储引擎层查找到当前记录的下一条记录时，在对其加锁前就直接判断该记录是否满足等值匹配的条件，如果不满足直接返回（也就是不加锁了）而不是先去加锁，再判断边界

2. ... for update
类似 加x锁

3. update hero set coutry = “汉" where name = "曹"

和2类似，但是如果更新的列有其他二级索引的记录，也要加锁

加锁顺序：''二级索引记录 - 聚簇 - 其他二级索引记录''

4. delete

和3类似，''但是它应该是给所有关联到的二级索引列加锁''

''总结：加锁顺序二级索引-聚簇索引，如果更新了其他二级索引就是'二级索引记录 - 聚簇 - 其他二级索引记录''


! 使用二级索引进行范围查询
结合前面，其实和上一种一样，只不过增加了范围，因此顺序就是：二级索引-聚簇索引 - 其他二级索引 - server层判断 -下一条的二级索引-聚簇索引，。。判断越界了还要把最后那条的所有锁释放

注意，select这其中可能会有不符合[[ICP|ICP:索引条件下推]]的语句，此时该记录不再回表，继续查询二级索引后面的记录，''然而，并不会释放不符合ICP条件的记录上的锁，作者也不知道为什么''

! 全表扫描的情况
这其实和''使用主键进行范围查询的情况''类似了,只不过不存在innodb引擎判断边界的情况了，但是会有server判断条件成立的步骤，然后会有解锁情况。
