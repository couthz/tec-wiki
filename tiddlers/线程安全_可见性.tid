created: 20220620062212254
creator: TidGiUser
modified: 20220624073155116
modifier: TidGiUser
tags: 多线程
title: 线程安全:可见性
type: text/vnd.tiddlywiki


谈到内存可见性，要先引出 JMM (Java Memory Model) 概念，JMM 即 Java 内存模型。JMM 规定，将所有的变量都存放在公共主内存中，当线程使用变量时，会把主存里面的变量复制到自 己的工作空间或者叫作私有内存中，线程对变量的读写操作，在自己工作内存中的变量。

如果两个线程同时操作一个共享变量，就可能发生可见性问题

[img[截屏2022-06-23 11.19.44.png]]

! JMM

JMM(Java Memory Model)即 Java 内存模型。''JMM 并不像 JVM 内存结构一样是真实存在的运行实体，更多体现为一种规范和规则。''

''JMM 定义了一组规则或规范，该规范定义了一个线程对共享变量的写入时，如何确保对另一个线程是可见的。 实际上 JMM 提供了合理的禁用缓存以及禁止重排序的方法，所以其最核心的价值在于解决可见性和有序性。''

Java 内存模型规定所有的变量都是存储在主存当中，JMM 的主存类似于物理内存，但有区别，还能包含部分共享缓存。每个 Java 线程都有自己的工作内存(类似于CPU高速缓存，但也有区别)。

(1)主内存:主要存储的是 Java 实例对象，所有线程创建的实例对象都存放在主内存中， 不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、 常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。

(2)工作内存:主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量 副本)，每个线程只能访问自己的工作内存，即线程中的本地变量对其他线程是不可见的，就算是 两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量， 当然也包括了字节码行号指示器、相关 Native 方法的信息。注意由于工作内存是每个线程的私有 数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。

Java内存模型的规定:

(1)所有变量存储在主内存中。 

(2)每个线程都有自己的工作内存，且对变量的操作都是在工作内存中进行。

(3)不同线程之间无法直接访问彼此工作内存中的变量，要想访问只能通过主内存来传递。

''因此JMM模型也需要解决代码重排序和缓存可见性问题。''所以，JMM 提供了一自己的方案去禁用缓存以及禁止重排序，来解决这些可见性和有序性问题。JMM 提供的方案包括大家都很熟悉: volatile、synchronized、final 等等。JMM 定义了一些内存操作的抽象指令集，然后将这些 抽象指令包含到 Java 的 volatile、synchronized 等关键字的语义中，''并要求JVM在实现这些关键字时必须具备其包含的 JMM 抽象指令的能力。''

JMM 与硬件内存架构的关系:

[img[截屏2022-06-23 20.58.23.png]]

> 这样看来,volatile关键字和mesi没有什么必然的联系, JMM定义的主存-工作内存的模型,完全屏蔽了不同系统架构的差异

! 总结

JMM将所有的存储(内存,cache,寄存器)抽象成主内存,工作内存. 屏蔽了任何的硬件的内存实现,''它只是表达了由于有工作内存的存在,可能会导致线程安全问题(可见性, 有序性(可见性也会导致有序性)), 而工作内存有可能是cache,也有可能是寄存器.''

JMM 定义了一些内存操作的抽象指令集, 这些抽象指令包含到 Java 的 volatile、synchronized 等关键字的语义中，''并要求JVM在实现这些关键字时必须具备其包含的 JMM 抽象指令的能力, 但究竟怎么实现,不同的底层实现方法不同, 不如有些系统根本不支持MESI协议, 其实就要借助其他方式了''

volatile的语义是为了从软件层面来保证可见性和有序性。它并不关注底层是通过什么技术来实现的，因此单靠MESI并不能满足volatile，它只是volatile语义实现的一部分, 就算没有volatile, MESI也是默认生效的

首先从可见性来说，虽然有缓存一致性协议可以保证各个CPU从缓存到主存之间的一致性。但问题是，数据得先到高速缓存才行啊，它可能还在写缓冲区storeBuffer。而且，对于有的CPU架构，还有无效化队列invalidQueue。

而volatile的目的就是告诉cpu，这个变量不需要缓冲区中而是每次都强制刷到缓存。只要刷到缓存，因为MESI或者其它缓存一致性协议的实现，各CPU缓存一致，所以即可实现可见性

原文链接：https://blog.csdn.net/foxException/article/details/119774421

volatile的lock的实现还要区分，这个数据在不在CPU核心的专有缓存中（一般是指L1/L2）。如果在，MESI才有用武之地。如果不满足就会要用其他手段。而这些手段是虚拟机开发者，以及操作系统开发者需要考虑的问题。简而言之，CPU里的缓存，buffer，queue有很多种(''JMM将它们都抽象成了工作内存和主内存'')。MESI只能在一种情况下解决核心专有Cache之间不一致的问题。

此外，如果有些CPU不支持MESI协议，那么必须用其他办法来实现等价的效果，比如总是用锁总线的方式，或者明确的fence指令来保证volatile想达到的目标。

如果CPU是单核心的，cache是专供这个核心的，MESI理论上也就没有用了。但是依然要考虑主存和Cache被多个线程切换访问时带来的不一致问题。''总之，volatile是一个高层的表达意图的“抽象”，而MESI是为了实现这个抽象，在某种特定情况下需要使用的一个实现细节。''

作者：大宽宽
链接：https://www.zhihu.com/question/296949412/answer/760347883
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

