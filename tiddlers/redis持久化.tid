created: 20220624152831276
creator: TidGiUser
modified: 20220625035307277
modifier: TidGiUser
tags: redis fx
title: redis持久化
type: text/vnd.tiddlywiki

! 持久化的意义

redis持久化的意义，在于故障恢复.

没有持久化，意味着即使你立刻重启redis也是没数据的，在这段时间里可能大量的流量击穿缓存

! 两种持久化
通用知识点：存储层，无论是oracle，mysql，redis，都有两样东西：

1. 每隔一段时间生成内存中数据完整的快照/副本 （直接存数据）对应redis中rdb

2. 日志 （存增删改操作记录） 对应redis中aof

! rdb
!! 原理
问题:时点性, 例如, 8:00开启备份之后, 要么停止对外服务, 否则保存的数据就不是同一个时间点的数据

redis的解决方案: 写时复制. 保存8:00那一时刻的数据, 并且父进程继续对外提供服务,fork()出子进程完成持久化

写时复制的核心思想: 在子进程保存数据落盘的时候，父进程不太可能把所有数据都修改了，所以没必要复制所有数据，只需要在修改的时候复制就行了

(可能的步骤：父进程发现了当前内存的引用大于1，不直接赋值，而是指向一个新空间，再赋值）

!! 命令
1. 手动触发

save：同步阻塞持久化 （服务器准备关机维护了，使用save，不然最后一段数据会丢失）

bgsave：异步非阻塞进行持久化

2. 配置文件bgsave规则 到达某个条件触发

save 900 1  (也别时间太久一直没存)

save 300 10

save 60 10000

含义:

if (60s 到达10000次写操作） 

写磁盘

else if (300s 到达10次写操作）

写磁盘

else if (900s 到达1次写操作）

写磁盘

> 想关闭：save ""

> 这里注意一个问题，我们本身会限制redis占用的内存，一般不超过10G，否则持久化的过程会很漫长对。尽量不要让大量数据都堆在一个redis实例上

! 优缺点

1. 优点: 恢复速度快

2. 丢失的数据会比较多;不支持拉链, 只有一个dump.rdb,需要运维人为地隔一段时间保存数据



! aof
(类似于[[binlog]])

!! 原理
1. 主线程会把写操作追加到日志中

2. ''子线程在一定条件下进行重写''，从而不阻塞主线程处理其他命令，防止日志文件过大，进而导致恢复速度慢

!! 命令

在redis.conf中，可以配置rewrite策略

auto-aof-rewrite-percentage 100

auto-aof-rewrite-min-size 64mb

比如说上一次AOF rewrite之后，是128mb

然后就会接着128mb继续写AOF的日志，如果发现增长的比例，超过了之前的100%，256mb，就可能会去触发一次rewrite

但是此时还要去跟min-size，64mb去比较，256mb > 64mb，才会去触发rewrite

注: 破损文件修复

如果redis在append数据到AOF文件时，机器宕机了，可能会导致AOF文件破损

用redis-check-aof --fix命令来修复破损的AOF文件

!! 优缺点

优点: 丢失数据少

缺点: 

1. 理论上日志的体量会无限增大(append only), 也会导致恢复速度更慢

redis对此的解决方案, 重写:

4.0以前:抵消和整合命令，删除抵消的，合并重复的。（对同一个key某些操作可以抵消，重复的操作合并（例如push 1，incr改成incrby））,最终也是一个纯指令的日志文件，恢复成本还是高

4.0以后: 先将老数据rdb放到aof文件中，再将增量aof以指令方式保存，混合体。

2. AOF开启后，''支持的写QPS会比RDB支持的写QPS低，因为进行磁盘IO的频率更高'', 所以AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的

<<<
Redis 目前支持三种 AOF 保存模式，

no：redis不会主动调用flush（操作系统的fsync操作），内核满了自己去刷，可能会丢失接近一个buffer的数据（buffer不会很大，4k左右）

always：每次写都会调用flush

everysec：每秒调用flush，可能会丢失接近一个buffer的数据，但是概率上来讲丢的数据会比no少，相当于比no多了间隔1秒的flush操作
<<<
 
3. aof这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug

! 如何使用rdb和aof
RDB和AOF到底该如何选择

(1）不要仅仅使用RDB，虽然RDB恢复的快，也更健壮，但是会丢失很多数据

（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug

（3）''综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复''

> 注：rdb和aof可以同时开启，但如果开启了aof，恢复的时候只会用aof

<<<
注: 如果aof和rdb同时工作:

（1）如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis再执行AOF rewrite，那么就不会执行RDB snapshotting

（2）如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行AOF rewrite

（3）同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整
<<<

! 数据可靠性和性能的权衡
这是个额外需要关注的参数，no-appendsync-on-rewrite参数，

主线程追加日志的时候有可能刷磁盘，子线程重写的时候也有可能刷磁盘。

为yes时，主进程在子进程rdb或重写时，不会去调用flush争抢IO，降低磁盘压力，但显然导致有可能丢buffer中的数据：

选第二个

[img[redissync.png]]