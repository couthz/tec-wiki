created: 20220614113201110
creator: TidGiUser
difficulty: 5
due: 20220623111728192
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220621111728192
modifier: TidGiUser
reps: 1
retrievability: 1
review: 20220621111728192
stability: 2
tags: mysql事务(主要基于inoodb的原理) fx ?
title: 03.mysql锁
type: text/vnd.tiddlywiki

! mysql锁的分类
从思想理论上可以分为：悲观锁和乐观锁

悲观锁：认为它所保护的数据随时都会被修改，因此某个事务拿到锁，锁定数据后，任何事务都不能对该数据修改

乐观锁：基于数据版本（version），一般是通过为数据库表增加一个 “version” 字段来实现。''读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。''

>可以认为mvcc是以乐观锁为理论基础

粒度上可以分为：

（1）表级锁：开销小，加锁快；''不会出现[[死锁|mysql死锁]]''；锁定粒度大，发生锁冲突的概率最高，并发度最低。（innodb一般不用）

> 对于MyISAM、MEMORY、MERGE这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。
> 因为使用MyISAM、MEMORY、MERGE这些存储引擎的表在同一时刻只允许一个会话对表进行写操作，所以这些存储引擎实际上最好用在只读，或者大部分都是读操作，或者单用户的情景下

（2）行级锁：开销大，加锁慢；''会出现死锁''；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

（3）页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。（Innodb没有，bdb引擎）

! INNODB表级锁（比较鸡肋,一般不用）
1. 表级别S：共享锁  X：排他锁

''为了避免加表级X，S锁时循环查看每条记录是否有行锁，在给记录加行锁之前先在表上加意向锁IX，IS''

| |X |S|IX（行级X）|IS（行级S）|
| X|不|不|不|不|
| S|不|兼|不|兼|
| IX（行级X）|不|不|兼|兼|
| IS（行级S）|不|兼|兼|兼|

2. 表级别的AUTO-INC锁：

和列的AUTO_INCREMENT的实现原理有关：

（1）在一次插入记录数不确定时，如INSERT。。。SELECT语句，用AUTO-INC锁表，''注意，insert语句完成后就释放锁，而不是事务完成后释放''

（2）插入记录数能确定时，获取一个轻量级锁，''并且生成列的值之后就释放锁''，而不是insert完成后释放锁


! 行级锁使用过程

''语句开始时获取，事务结束时释放''

1. select：

S：select .. LOCK IN SHARE MODE

X: select .. FOR UPDATE

2. delete:

定位记录在B+树中的位置，然后获取X锁，执行delete mark操作，''可以看做是一个获取x锁的读''

3. update：三种情况？？

（1）如果未修改该记录的键值并且''被更新的列占用的存储空间在修改前后未发生变化？？？''，则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。''可以把这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读。''

（2）如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。''这个定位待修改记录在B+树中位置的过程看成是一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护''。

（3）如果修改了该记录的键值，则相当于在原记录上做DELETE操作之后再来一次INSERT操作，加锁操作就需要按照DELETE和INSERT的规则进行了。

4. insert

新插入一条记录的操作并不加锁，通过一种称之为''隐式锁''的东东来保护这条新插入的记录在本事务提交前不被别的事务访问。特殊情况下insert也加锁

! Innodb行锁类型
1. RecordLocks 记录锁，锁定在聚簇索引记录上的锁，包括S和X锁

2. Gap Locks 间隙锁，加在索引记录之间的锁，也可以有S和X

唯一作用：防止其他事务在这个间隙中插入记录，''即使分S和X，也并不会限制其他事务对这条记录加记录锁或者继续加gap锁，再强调一遍，gap锁的作用仅仅是为了防止插入幻影记录的而已''

> 注意聚簇索引底部链表首尾有Infimum和supremum记录，代表无穷大的两条伪记录

3. Next-key locks，本质上就是1+2，有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录

4. Insert Intention Locks 插入意向锁，作用仅仅是：insert遇到插入位置有Gap锁时会''等待''，同时生成一个插入意向锁，并且将is_waiting属性值为true。gap锁释放后，等待的insert都会获得插入意向锁，并不会互相阻塞

> 这里其实就和锁结构有关了
> ''这个其实可以看做insert加锁的一种情况''


5. insert的隐式锁

场景：

立即使用SELECT ... LOCK IN SHARE MODE语句读取这条记录，也就是在要获取这条记录的S锁，或者使用SELECT ... FOR UPDATE语句读取这条记录，也就是要获取这条记录的X锁，该咋办？如果允许这种情况的发生，那么可能产生[[脏读|01.事务隔离级别]]问题。

> ''从这句描述中看出，使用锁定读就不会生成readview了''

立即修改这条记录，也就是要获取这条记录的X锁，该咋办？如果允许这种情况的发生，那么可能产生[[脏写|01.事务隔离级别]]问题。

解决：隐式锁，''可以理解为一种“懒”的加锁方式''

> 感觉像锁升级，那为什么update不用这种办法呢

情景一：对于聚簇索引记录来说，事务A做了insert操作，如果事务B此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id隐藏列代表的事务是否是当前的活跃事务（''就是看看insert有没有提交''），如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构，is_waiting属性是false），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting属性是true）。

情景二：对于二级索引记录来说，本身并没有trx_id隐藏列，但是在二级索引页面的Page Header部分有一个PAGE_MAX_TRX_ID属性，该属性代表对该页面做改动的最大的事务id，''如果PAGE_MAX_TRX_ID属性值小于当前最小的活跃事务id，那么说明对该页面做修改的事务都已经提交了''，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复情景一的做法。

! innodb锁结构
[img[截屏2022-06-14 23.30.25.png]]

! 是否可重入？？
是否则select for update执行完，update就不能执行了






