created: 20220617012603551
creator: TidGiUser
difficulty: 5
due: 20220623111806915
grade: -1
history: []
interval: 0
lapses: 0
modified: 20220621111806916
modifier: TidGiUser
reps: 1
retrievability: 1
review: 20220621111806915
stability: 2
tags: fx HashMap ?
title: HashMap:散列冲突
type: text/vnd.tiddlywiki


! 核心问题:散列冲突
根据定义,理想情况下应该是通过散列函数映射得到一个唯一下标,这就要求散列函数的结果有如下要求:

[img[截屏2022-06-17 17.07.13.png]]

但是在真实的情况下，要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的:

1. 函数本身设计成没有冲突的就很难:即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。

2. 另外一般代码中都是取hash再取模，因为数组的存储空间有限，也会加大散列冲突的概率。


> 散列冲突攻击:在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。



! 预防策略:设计散列函数
!! String的hashcode属性
> [[Object类为什么规定重写hashcode和equals方法|equals 和 ==的区别 ？？为什么要重写equals和hashcode]]

明白了为什么重写之后, 再看看String的hashcode是怎么重写的

```java
char val[] = value;
for (int i = 0; i < value.length; i++) {
      h = 31 * h + val[i];
}
```
[img[imagfdfdffde.png]]
''effective java的说法：''

1. 之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。

2. 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i << 5）- i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。

3. 另外，实验证明，用31的碰撞概率很小。

!! hashmap的扰动函数

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

原因:

> 注: 计算value最终索引值的方法一般是取hash值再对length取模，而java更高效的的方式是：hashmap的长度必须是2的幂，这样hash%length = hash&(length-1）,另外java假设length一般很少超过2^16（65536），因此计算索引时hash&(length-1），hash值参与运算的部分一般只有低16位，
> 
1. 为了提高最终索引值随机性，让高16位也参与运算，扰动的办法就是hashcode高16位和低16位进行运算

2. 为什么用异或呢，因为用&或者｜都会让结果趋向于0或1，反而不平均了

!! 负载因子

```java
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

装载因子越大，说明散列表中的元素越多，
空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢,要选择一个合理的大小下进行扩容，默认值0.75就是说当阀值容量占了3/4时赶紧''扩容''，减少Hash碰撞。

!! 1.8对扩容性能的优化
> 不是重新计算下标,而是用(hash & oldcap)判断,=0不移动,解释如下:

1. 每次扩容都是2倍, hashmap的长度也是2的幂次,每次取模就是^(2^n - 1),''2^n - 1的二进制其实就是n个1, 所以扩容前与运算的因子是n个1,扩容后与运算的因子就是n+1个1''

2. 因此就是看元素的hash值(扰动后)的二进制,n+1位为0,保持原位,否则就增加扩容位数(2^n)

对31取模保留低5位，对15取模保留低4位，两者的差异就在于第5位是否为1，是的话则需要加上增量，为0的话则不需要改变
[img[18扩容.png]]

>[[redis hashtable的扩容方法|redis数据结构:hashtable]]

! 事后解决散列冲突的几种办法
1. 开放寻址法

插入: 遇到冲突就沿着数组向后找(到了尾部重新回头部),找到第一个空位就存 (''从散列值的位置开始,直到插入位置,中间一定都没有空位,这一点也影响了查询逻辑'')

查找: 类似于插入,遇到冲突就沿着数组向后找(到了尾部重新回头部),并且比较元素值是否相等,如果找到第一个空位就表示没有该元素(''这一点也影响了删除逻辑,不能直接删除,只能设置deleted标志'')

2. 链表法

在散列表中，每个“桶(bucket)”或者“槽(slot)”会对应一条链表

当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即 可，所以插入的时间复杂度是 ''O(1)''。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢?

实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 ''O(k)''。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。
